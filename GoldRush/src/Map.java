import java.util.ArrayList;
import java.util.Random;

public class Map {

	private Random gen;

	// used later to help the miner find his current location
	private Location SutterCreek;
	private Location Coloma;
	private Location AngelsCamp;
	private Location NevadaCity;
	private Location VirginiaCity;
	private Location Midas;
	private Location ElDoradoCanyon;

	private Road SutterCreek_AngelsCamp;
	private Road AngelsCamp_NevadaCity;
	private Road AngelsCamp_VirginiaCity;
	private Road SutterCreek_Coloma;
	private Road VirginiaCity_Coloma;
	private Road VirginiaCity_Midas;
	private Road Midas_ElDoradoCanyon;
	private Road VirginiaCity_ElDoradoCanyon;

	private Graph G;
	private ArrayList<Location> neighboringLocations;
	private ArrayList<Location> visitedLocations;
	int visitedUniqueLocations;

	public Map(Random gen) {
		G = new Graph();
		this.gen = gen;
		visitedLocations = new ArrayList<>();

		/******************
		 * REQUIREMENT #10*********************** Prospectors shall find the following
		 * amounts of gold and silver at each iteration at each location. Note that the
		 * numbers indicated are a maximum.
		 * 
		 * Location | Max Silver | Max Gold ------------------------------------ Sutter
		 * Creek | 0 | 2 Coloma | 0 | 3 Angels Camp | 0 | 4 Nevada City | 0 | 5 Virginia
		 * City| 3 | 3 Midas | 5 | 0 El Dorado Cn | 10 | 0
		 * ------------------------------------
		 */

		// 7 Locations (i.e., cities)
		// Note: the official names have spaces
		this.SutterCreek = new Location("Sutter Creek", 0, 2);
		this.Coloma = new Location("Coloma", 0, 3);
		this.AngelsCamp = new Location("Angels Camp", 0, 4);
		this.NevadaCity = new Location("Nevada City", 0, 5);
		this.VirginiaCity = new Location("Virginia City", 3, 3);
		this.Midas = new Location("Midas", 5, 0);
		this.ElDoradoCanyon = new Location("El Dorado Canyon", 10, 0);

		// 8 Roads connecting cities
		this.SutterCreek_AngelsCamp = new Road(SutterCreek, AngelsCamp);
		this.AngelsCamp_NevadaCity = new Road(AngelsCamp, NevadaCity);
		this.AngelsCamp_VirginiaCity = new Road(AngelsCamp, VirginiaCity);
		this.SutterCreek_Coloma = new Road(SutterCreek, Coloma);
		this.VirginiaCity_Coloma = new Road(VirginiaCity, Coloma);
		this.VirginiaCity_Midas = new Road(VirginiaCity, Midas);
		this.Midas_ElDoradoCanyon = new Road(Midas, ElDoradoCanyon);
		this.VirginiaCity_ElDoradoCanyon = new Road(VirginiaCity, ElDoradoCanyon);

		// Add Locations to Map
		G.addLocation(NevadaCity);
		G.addLocation(AngelsCamp);
		G.addLocation(VirginiaCity);
		G.addLocation(SutterCreek);
		G.addLocation(Coloma);
		G.addLocation(Midas);
		G.addLocation(ElDoradoCanyon);

		// Add Roads connecting cities to Map
		G.addRoad(SutterCreek_AngelsCamp);
		G.addRoad(AngelsCamp_NevadaCity);
		G.addRoad(AngelsCamp_VirginiaCity);
		G.addRoad(SutterCreek_Coloma);
		G.addRoad(VirginiaCity_Coloma);
		G.addRoad(VirginiaCity_Midas);
		G.addRoad(Midas_ElDoradoCanyon);
		G.addRoad(VirginiaCity_ElDoradoCanyon);

		visitedLocations.add(SutterCreek);

	}

	// takes a String from Miner and returns a Location
	// this was the Location information remains stored in one place (the Map).
	// this allows us to pass Locations by reference).
	// technically, we only needed for SutterCreek for user, since map will handle
	// the rest via nextLocation()
	public Location getCurrentLocationInformation(String loc) {
		Location location = this.SutterCreek;
		if (loc.equals("SutterCreek")) {
			location = SutterCreek;
		}
		// we will need these for testing to get the Location object from Map
		else if (loc.equals("Coloma")) {
			location = Coloma;
		} else if (loc.equals("AngelsCamp")) {
			location = AngelsCamp;
		} else if (loc.equals("NevadaCity")) {
			location = NevadaCity;
		} else if (loc.equals("VirginiaCity")) {
			location = VirginiaCity;
		} else if (loc.equals("Midas")) {
			location = Midas;
		} else if (loc.equals("ElDoradoCanyon")) {
			location = ElDoradoCanyon;
		}
		return location;
	}

	// Returns the route number generated by Random
	private int getRoute() {
		return gen.nextInt(neighboringLocations.size());
	}

	// Returns an ArrayList of all neighboring locations
	public ArrayList<Location> getAllNeighbors(Location currentLocation) {
		neighboringLocations = G.getAdjacentVertices(currentLocation);
		return neighboringLocations;
	}

	// The nextLocation takes the currentLocation and return the next location
	public Location nextLocation(Location currentLocation) {
		Location nextLocation = null;
		neighboringLocations = getAllNeighbors(currentLocation);
		nextLocation = neighboringLocations.get(getRoute());
		add(nextLocation);
		return nextLocation;
	}

	public void add(Location nextLocation) {
		if (visitedLocations.contains(nextLocation)) {
			// do nothing if location is in list
		} else {
			visitedLocations.add(nextLocation);
		}
	}
}
